import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class MishrasMethod {

	public static String setToString(HashSet<String> s1) {
		StringBuilder sb = new StringBuilder();
		for (String s : s1) {
			sb.append(s);
		}
		return sb.toString();
	}

	public static ArrayList<String> getNGrams(ArrayList<String> incodes, int n)
			throws IOException {
		ArrayList<String> opseq = new ArrayList<String>();
		String[] ops = new String[n];
		int index = 0;
		for (String line : incodes) {
			line = line.trim();
			ops[index % n] = line;
			if (index >= 2) {
				HashSet<String> s1 = new HashSet<String>(Arrays.asList(ops));
				opseq.add(index - 2, setToString(s1));
			}
			index++;
		}
		return opseq;
	}

	public static Map<Integer, HashSet<Integer>> compareOpcodes(
			ArrayList<String> f1, ArrayList<String> f2) {
		int m = f1.size();
		int n = f2.size();
		
		System.out.println("f1.size"+m+"f2.size"+n);
		// row col
		Map<Integer, HashSet<Integer>> sparse_matrix = new HashMap<Integer, HashSet<Integer>>();
		for (int i = 0; i < m; i++) {
			HashSet<Integer> curr_col = new HashSet<Integer>();
			String op1 = f1.get(i);
			for (int j = 0; j < n; j++) {
				if (op1.equals(f2.get(j))) {
					curr_col.add(j);
				}
			}
			if (curr_col.size() > 0) {
				sparse_matrix.put(i, curr_col);
			}
			if (i % 100 ==0) {
				System.out.println("Processing line " + i + " of " + m);
			}
		}
		return sparse_matrix;
	}

	public static boolean LookupSparseMatrix(
			Map<Integer, HashSet<Integer>> matrix, int i, int j) {
		if (!matrix.containsKey(i)) {
			return false;
		}
		return matrix.get(i).contains(j);
	}

	/*
	 * 1 0 0 0
	 * 0 1 0 0
	 * 0 0 1 0
	 * 0 0 0 1
	 * 0 0 0 1 
	 */
	 
	 
	public static int segmentLength(Map<Integer, HashSet<Integer>> matrix,
			int i, int j) {
		int l1 = 100;//matrix.length;
		int l2 = 100;//matrix[0].length;

		int length = 1;
		int x = i - 1;
		int y = j - 1;
		while (x >= 0 && y >= 0) {
			if (LookupSparseMatrix(matrix, x, y)) {
				length++;
				x--;
				y--;
			} else {
				break;
			}
		}
		x = i + 1;
		y = j + 1;
		while (x < l1 && y < l2) {
			if (LookupSparseMatrix(matrix, x, y)) {
				length++;
				x++;
				y++;
			} else {
				break;
			}
		}
		return length;
	}

	public static double compareFiles(ArrayList<String> f1, ArrayList<String> f2)
			throws IOException {
		if (f1.size() == 0 || f2.size() == 0)
			return 0.0;
		System.out.println("Mishra ngram 1");

		ArrayList<String> op1 = getNGrams(f1, 3);
		System.out.println("Mishra ngram 2");
		ArrayList<String> op2 = getNGrams(f2, 3);
		System.out.println("Mishra ngram done");

		if (op1.size() == 0 || op2.size() == 0)
			return 0.0;
		Map<Integer, HashSet<Integer>> matrix = compareOpcodes(op1, op2);
		System.out.println("Mishra compare opcodes");

		Set<Integer> matchset1 = new HashSet<Integer>();
		Set<Integer> matchset2 = new HashSet<Integer>();
		System.out.println("op1 size :" + op1.size());
		System.out.println("op2 size :" + op2.size());
		// Optimize later.
		int count = 0;
		for (int i = 0; i < op1.size(); i++) {
			for (int j = 0; j < op2.size(); j++) {
				if (LookupSparseMatrix(matrix, i, j)) {
					count += 1;
					matchset1.add(i);
					matchset2.add(j);					
				}
				
				// if (matrix[i][j] && segmentLength(matrix, i, j) > 5) {
				// if (matrix[i][j]){//&& segmentLength(matrix, i, j) > 5) {
				// matchset1.add(i);
				// matchset2.add(j);
				// }
			}
		}
		System.out.println("Mishra match set  done");

		double match1size = matchset1.size();
		double op1size = op1.size();
		double match2size = matchset2.size();
		double op2size = op2.size();
		double score1 = match1size / op1size;
		double score2 = match2size / op2size;
		double score = (score1 + score2) / 2;
		return score;
	}
}
