import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Hashtable;
import java.util.List;
import java.util.Random;
import java.util.Set;

public class CodeMorphingTool {

	Hashtable<String, List<String>> substituteMap;
	List<String> opcodeList;

	List<List<String>> deadCodeList;
	Hashtable<String, List<String>> randomSubsMap;
	static Random rand;
	String kUniqueOpcodes = null;

	CodeMorphingTool(String kUniqueOpcodes) throws IOException {
		rand = new Random();

		// Initialize subs map here
		substituteMap = new Hashtable<String, List<String>>();
		substituteMap.put("mov",
				new ArrayList<>(Arrays.asList("add", "push", "pop")));
		substituteMap.put("add",
				new ArrayList<>(Arrays.asList("add", "add", "add")));
		substituteMap.put("add", new ArrayList<>(Arrays.asList("sub")));
		substituteMap.put("sub", new ArrayList<>(Arrays.asList("add")));

		// Negation is a sub opr
		substituteMap.put("neg", new ArrayList<>(Arrays.asList("sub")));

		// dec and increment operators
		substituteMap.put("dec", new ArrayList<>(Arrays.asList("sub")));
		substituteMap.put("inc", new ArrayList<>(Arrays.asList("add")));

		// Jump on conditions.
		substituteMap.put("jne", new ArrayList<>(Arrays.asList("jmp")));
		substituteMap.put("jnp", new ArrayList<>(Arrays.asList("jmp")));
		substituteMap.put("jns", new ArrayList<>(Arrays.asList("jmp")));
		substituteMap.put("jcxz", new ArrayList<>(Arrays.asList("jmp")));

		// a xor b = ((not(a) & b) || (not(b) & a ))
		substituteMap
		.put("xor",
				new ArrayList<>(Arrays.asList("not", "and", "not",
						"and", "or")));

		substituteMap.put(
				"nop", 	new ArrayList<>(Arrays.asList("nop", "nop", "nop", "nop",
						"nop", "nop")));

		// Initialize dead code list here.
		deadCodeList = new ArrayList<List<String>>();
		deadCodeList.add(new ArrayList<>(Arrays.asList("jmp", "push", "pop",
				"push", "pop")));
		deadCodeList.add(new ArrayList<>(Arrays.asList("nop")));

		// Initialize opcodeSet
		opcodeList = new ArrayList<String>();

		BufferedReader br = new BufferedReader(new FileReader(kUniqueOpcodes));
		String line = null;
		while ((line = br.readLine()) != null) {
			opcodeList.add(line);
		}
		br.close();

		// Initialize random subs map.
		randomSubsMap = new Hashtable<String, List<String>>();

	}

	public List<String> getRandomOpcodes(int n) {
		List<String> random_list = new ArrayList<String>();

		for (int i = 0; i < n; i++) {
			int k = rand.nextInt(opcodeList.size());
			random_list.add(opcodeList.get(k));
		}
		return random_list;
	}

	public List<String> writeRandomOpcodes(BufferedWriter wr)
			throws IOException {
		int k = rand.nextInt(10);
		List<String> ops = getRandomOpcodes(k);
		for (String o : ops) {
			wr.write(o);
		}
		return ops;
	}

	// Consumes n opcodes.
	public static void deleteOpcodes(BufferedReader br, int n)
			throws IOException {
		String line = null;
		for (int i = 0; i < n; i++) {
			line = br.readLine();
			if (line == null)
				break;
		}
	}

	public static void deleteOpcodes(BufferedReader br) throws IOException {
		int k = rand.nextInt(10);
		deleteOpcodes(br, k);
	}

	public void morphFile(String inputfile, String outfile, double ins_ratio,
			double subs_ratio, double trans_ratio, double del_ratio)
					throws IOException {
		BufferedReader br = new BufferedReader(new FileReader(inputfile));
		BufferedWriter wr = new BufferedWriter(new FileWriter(outfile));

		System.out.println("processing file " + inputfile);
		int count = 0;
		String line = null;

		double l1 = ins_ratio;
		double l2 = ins_ratio + subs_ratio;
		double l3 = ins_ratio + subs_ratio + trans_ratio;
		double l4 = ins_ratio + subs_ratio + trans_ratio + del_ratio;

		//System.out.println(+l1+" "+l2+" "+l3+" "+l4);
		while ((line = br.readLine()) != null) {
			double r = rand.nextDouble();
			if (r < l1) {
				writeRandomOpcodes(wr);
				count++;
			} else if (r < l2) {
				subsitute(line, br, wr);
				count++;
			} else if (r < l3) {
				transpose(br, wr, 5, 25);
				count++;
			} else if (r < l4) {
				deleteOpcodes(br);
				count++;
			}
			else
			{
				wr.write(line);
				wr.newLine();
			}
		}
		System.out.println("the no of lines morphed" + count);
		br.close();
		wr.close();

	}

	/*
	 * Moves N opcodes after skipping S positions.
	 */
	private void transpose(BufferedReader br, BufferedWriter wr,
			int num_opcodes, int skip_position) throws IOException {
		// TODO: Insert appropriate JMP/RETURN statements.

		List<String> opcodes = new ArrayList<String>();
		String line = null;
		for (int i = 0; i < num_opcodes; i++) {
			line = br.readLine();
			if (line == null)
				break;
			opcodes.add(line);
		}

		for (int i = 0; i < skip_position; i++) {
			line = br.readLine();
			if (line == null)
				break;
			wr.write(line);
		}

		for (String o : opcodes) {
			wr.write(o);
		}

	}

	private void morphOpcode(String line, BufferedReader br, BufferedWriter wr)
			throws IOException {
		double r = rand.nextDouble();
		if (r < .25) {
			writeRandomOpcodes(wr);
		} else if (r < .5) {
			deleteOpcodes(br);
		} else if (r < .75) {
			transpose(br, wr, 5, 25);
		} else {
			subsitute(line, br, wr);
		}

	}

	private void subsitute(String opcode, BufferedReader br, BufferedWriter wr)
			throws IOException {
		// If opcode has a entry in substitute map, use that list. Else insert
		// some random opcodes.
		if (substituteMap.containsKey(opcode)) {
			for (String s : substituteMap.get(opcode)) {
				wr.write(s);
			}
		} else {
			writeRandomOpcodes(wr);
		}
	}

	public void writeMorph(String input_dir, String output_dir,
			double ins_ratio, double subs_ratio, double trans_ratio,
			double del_ratio) throws IOException {

		// mwor_0.5
		File[] base_file = new File(input_dir).listFiles();
		for (File f : base_file) {
			String infile = input_dir + f.getName();
			String outfile = output_dir + f.getName() + "_morph";
			morphFile(infile, outfile, ins_ratio, subs_ratio, trans_ratio,
					del_ratio);
		}

	}

	public static void main(String[] args) throws IOException {

		String base_dir="/Users/vinodh/abitha/Fall2015/CS298/InputOpcodes/mwor_opcodes/mwor_base/";
		String outfile_dir="/Users/vinodh/abitha/Fall2015/CS298/InputOpcodes/mwor_opcodes/mwor_del_morph/mwor_del_0.4/";
		String kUniqOpcodes="/Users/vinodh/abitha/Fall2015/CS298/InputOpcodes/mwor_opcodes/mwor_uniq_symbols.txt";

		double ins_ratio = 0.0, subs_ratio = 0, trans_ratio = 0, del_ratio = 0.4;

		CodeMorphingTool morpher = new CodeMorphingTool(kUniqOpcodes);
		morpher.writeMorph(base_dir, outfile_dir, ins_ratio, subs_ratio,
				trans_ratio, del_ratio);
		System.out.println("Morphing completed:check files");

	}
}
//String base_dir = "/home/dragon/abitha/CS297/InputFiles/obfuscate/obfus_Input/";
//String outfile_dir = "/home/dragon/abitha/CS297/InputFiles/obfuscate/obfus_output/";
/**
String base_dir="/home/dragon/Downloads/DatasetfromFabio/tmp/winwebsec/morphinput/";
String outfile_dir = "/home/dragon/Downloads/DatasetfromFabio/tmp/winwebsec/morphoutput-40-percent/";
 **/
//String base_dir="/home/dragon/abitha/CS297/DeletionMorphOutput/0.1-0.1-0.1/";
//String outfile_dir="/home/dragon/abitha/CS297/DeletionMorphOutput/0.1-0.1-0.1-0.1/";
//
//String base_dir="/Users/vinodh/abitha/Fall2014/CS297/0_5/";
//String outfile_dir="/Users/vinodh/abitha/Fall2014/CS297/morph_0_5_del/";

//String base_dir="/Users/vinodh/abitha/Fall2015/CS298/OpcodeGraph/zbot/zbot_base/";
//String outfile_dir="/Users/vinodh/abitha/Fall2015/CS298/OpcodeGraph/zbot/zbot_del_0.1/";
//
//String base_dir="/Users/vinodh/abitha/Fall2015/CS298/OpcodeGraph/zbot/zbot_base/";
//String outfile_dir="/Users/vinodh/abitha/Fall2015/CS298/OpcodeGraph/zbot/zbot_del_0.4/";
