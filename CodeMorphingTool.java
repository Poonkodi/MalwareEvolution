import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Random;

public class CodeMorphingTool {
	Hashtable<String, List<String>> substituteMap;
	List<String> opcodeList;
	List<List<String>> deadCodeList;
	Hashtable<String, List<String>> randomSubsMap;
	static Random rand;
	String kUniqueOpcodes = null;
	int transpose_linecount = 0;
	int noof_jumbled = 0;

	CodeMorphingTool(File kUniqueOpcodes) throws IOException {
		rand = new Random();
		// // Initialize subs map here
		// substituteMap = new Hashtable<String, List<String>>();
		// substituteMap.put("mov",
		// new ArrayList<>(Arrays.asList("add", "push", "pop")));
		// substituteMap.put("add",
		// new ArrayList<>(Arrays.asList("add", "add", "add")));
		// substituteMap.put("add", new ArrayList<>(Arrays.asList("sub")));
		// substituteMap.put("sub", new ArrayList<>(Arrays.asList("add")));
		// // Negation is a sub opr
		// substituteMap.put("neg", new ArrayList<>(Arrays.asList("sub")));
		// // dec and increment operators
		// substituteMap.put("dec", new ArrayList<>(Arrays.asList("sub")));
		// substituteMap.put("inc", new ArrayList<>(Arrays.asList("add")));
		// // Jump on conditions.
		// substituteMap.put("jne", new ArrayList<>(Arrays.asList("jmp")));
		// substituteMap.put("jnp", new ArrayList<>(Arrays.asList("jmp")));
		// substituteMap.put("jns", new ArrayList<>(Arrays.asList("jmp")));
		// substituteMap.put("jcxz", new ArrayList<>(Arrays.asList("jmp")));
		// // a xor b = ((not(a) & b) || (not(b) & a ))
		// substituteMap.put("xor",new ArrayList<>(Arrays.asList("not", "and",
		// "not","and", "or")));
		// substituteMap.put("nop",new ArrayList<>(Arrays.asList("nop", "nop",
		// "nop", "nop",
		// "nop", "nop")));
		// // Initialize dead code list here.
		// deadCodeList = new ArrayList<List<String>>();
		// deadCodeList.add(new ArrayList<>(Arrays.asList("jmp", "push", "pop",
		// "push", "pop")));
		// deadCodeList.add(new ArrayList<>(Arrays.asList("nop")));

		// Initialize opcodeSet
		opcodeList = new ArrayList<String>();

		BufferedReader br = new BufferedReader(new FileReader(kUniqueOpcodes));
		String line = null;
		while ((line = br.readLine()) != null) {
			opcodeList.add(line);
		}
		br.close();
		// Initialize random subs map.
		randomSubsMap = new Hashtable<String, List<String>>();
	}

	public List<String> getRandomOpcodes(int n) {
		List<String> random_list = new ArrayList<String>();

		for (int i = 0; i < n; i++) {
			int k = rand.nextInt(opcodeList.size());
			random_list.add(opcodeList.get(k));
		}
		return random_list;
	}

	public List<String> writeRandomOpcodes(ArrayList<String> output_codes)
			throws IOException {
		int k = 1+ rand.nextInt(10);
		List<String> ops = getRandomOpcodes(k);
		for (String o : ops) {
			output_codes.add(o);
		}
		return ops;
	}

	public List<String> substituteRandomOpcodes(ArrayList<String> output_codes)
			throws IOException {
		int k = rand.nextInt(3) + 1;
		List<String> ops = getRandomOpcodes(k);
		for (String o : ops) {
			output_codes.add(o);
		}
		return ops;
	}

	// Moves N opcodes after skipping S positions.
	private int transpose(ArrayList<String> input_codes, int ip_pos,
			ArrayList<String> output_codes) throws IOException {
		// TODO: Insert appropriate JMP statements.
		List<String> opcodes = new ArrayList<String>();
		int i = ip_pos;
		int k1 = rand.nextInt(10);
		transpose_linecount += k1;
		for (i = ip_pos; i < ip_pos + k1; i++) {
			if (i >= input_codes.size())
				break;
			opcodes.add(input_codes.get(i));
		}

		output_codes.add("jmp");
		int k2 = rand.nextInt(10);
		for (i = ip_pos + k1; i < ip_pos + k1 + k2; i++) {
			if (i >= input_codes.size())
				break;
			output_codes.add(input_codes.get(i));
		}
		output_codes.add("jmp");
		output_codes.addAll(opcodes);
		output_codes.add("jmp");
		return i;
	}

	public ArrayList<String> morphFile(ArrayList<String> input_codes,
			double ins_ratio, double subs_ratio, double trans_ratio,
			double del_ratio) throws IOException {
		int count = 0;
		double l1 = ins_ratio;
		double l2 = ins_ratio + subs_ratio;
		double l3 = ins_ratio + subs_ratio + trans_ratio;
		double l4 = ins_ratio + subs_ratio + trans_ratio + del_ratio;

		ArrayList<String> output_codes = new ArrayList<String>();

		for (int i = 0; i < input_codes.size(); i++) {
			String current_code = input_codes.get(i);
			double r = rand.nextDouble();
			if (r < l1) {
				output_codes.add(current_code);
				writeRandomOpcodes(output_codes);
				count++;
			} else if (r < l2) {
				substituteRandomOpcodes(output_codes);
				count++;
			} else if (r < l3) {
				int start_pos = i;
				i += transpose(input_codes, i, output_codes);
				noof_jumbled = i - start_pos;

				count++;
			} else if (r < l4) {
				// Delete opcodes;
				i += rand.nextInt(10);
				if (i > input_codes.size())
					break;
				count++;
			} else {
				output_codes.add(current_code);
			}
		}
		return output_codes;
	}

	// Consumes n opcodes.
	public static void deleteOpcodes(BufferedReader br, int n)
			throws IOException {
		String line = null;
		for (int i = 0; i < n; i++) {
			line = br.readLine();
			if (line == null)
				break;
		}
	}

	public static void deleteOpcodes(BufferedReader br) throws IOException {
		int k = 1 + rand.nextInt(10);
		deleteOpcodes(br, k);
	}

	public Map<String, ArrayList<String>> getMultiMorph(
			ArrayList<String> input_codes) // String output_dir)
			throws IOException {
		 double[] morph_values = { 0.1, 0.2, 0.3, 0.4 };
//		double[] morph_values = { 0.001 };// , 0.002, 0.003, 0.004 };
		Map<String, ArrayList<String>> group = new HashMap<String, ArrayList<String>>();
		System.out.println("Morphing file");

		for (double mv : morph_values) {
			System.out.println("Morphing ins " + mv);
			ArrayList<String> ins = morphFile(input_codes, mv, 0.0, 0.0, 0.0);
			group.put("ins_" + mv, ins);

			System.out.println("Morphing subs " + mv);
			ArrayList<String> subs = morphFile(input_codes, 0.0, mv, 0.0, 0.0);
			group.put("subs_" + mv, subs);

//			System.out.println("Morphing trans " + mv);
//			ArrayList<String> trans = morphFile(input_codes, 0.0, 0.0, mv, 0.0);
//			group.put("trans_" + mv, trans);

			System.out.println("Morphing del " + mv);
			ArrayList<String> del = morphFile(input_codes, 0.0, 0.0, 0.0, mv);
			group.put("del_" + mv, del);
			// Save to files.
		}
		System.out.println("Morphing Done");
		System.out.println("no of jumbled" + noof_jumbled);
		System.out.println("no of transpose line count" + transpose_linecount);

		// System.out.println("col size morph : " + group.size());
		return group;
	}
}
